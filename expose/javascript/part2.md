1. Line 12 will print out 3 because the input array we are giving it is of size 3, meaning that i will start out at 0, and get incremented once after every value in the prices array. After getting incremeneted the third time (the value is 3), the expression i < prices.length will return false because they are both equal to three, meaning it will not enter the loop again. Since i was declared with var, its scope is the entire function, meaning printing i will print the last value i was set to, 3. 
2. Line 13 prints out 150 because the last value that discountedPrice was set to was the last element in the prices array which was 300 and the discount was 50% (0.5), meaning the discounted price is 150. It is in scope for the function, so there is no error.
3. Line 14 will also print out 150 because, same as above, the discountedPrice is 150. Since final price will round the value of discounted price using Math.round and by multiplying and dividing discounted price by 100. Since it is multiplied by 100 then divided by 100, the value will stay the same and print out 150. It is in scope for the function, so there is no error.
4. This function will return the discounted prices as an array (discounted) the same size as the prices array it was given, but discounted by the amount given as the second parater to the function. Specifically, it will return [50, 100, 150]. However, it will not return anything when called this way because the value is not being stored and/or printed. 
5. At line 12, this function will return an error when called because we used let instead of var to declare the variable i. Since we used let, we only have access to the variable within the block instead of throughout the entire function, meaning outside of the for loop, we cannot access i. Its scope ends after the for loop, so it returns an error saying that i is not defined. 
6. This function will return an error at line 13 because discountedPrice is declared using let inside of the for loop, meaning the rest of the function doesn't have access to it. Since line 13 is outside of the for loop, the scope of discountedPrice isn't reachable from there, meaning it will return an undefined variable error. 
7. Line 14 will print out 150 because finalPrice is declared at the top of the function, so the rest of the function has access to it. It returns 150 because the last price in the array that it is set to is 300 at a discount of 1-0.5, so the price is halved: 150. 
8. This function will return the discounted array [50, 100, 150] because although some of the print statements didn't work, the function has access to the discounted array throughout the function and it works properly. 
9. At line 11 this function will return an error because we declared i using let inside of the for loop, meaning the rest of the function outside of that loop doesn't have access to i. Its scope runs out before the console.log statement, so there is an undefined variable error. 
10. At line 12 it will print the length which is 3. It prints 3 because the length is constant and is defined as being the length of the prices array. Since the prices array is made up of three elements, [100, 200, 300], the length is three. Therefore, printing the length returns 3. 
11. This function will return the correct (intended) array [50, 100, 150] because the function as a whole is correct. Despite the discounted array being declared constant, we can still change and reassign the values inside of the array, just not the entire array. 
12. - A: student.name
    - B: student['Grad Year'] 
    - C: student.greeting();
    - D: student['Favorite Teacher'].name
    - E: student.courseLoad[1] (if you want index one, but student.courseLoad[0] if you want the first item in the array)
13. - A: '3' + 2 = '32' because it sees '3' as a string and + as the concatenate operation, so it parses both as strings. 
    - B: '3' - 2 = 1 because you cannot substract two string values, so it parses them as numbers.
    - C: 3 + null = 3 because null is equivalent to 0 when dealing with numeric conversion and 3 is parsed as a number. 
    - D: '3' + null = 3null because 3 is seen as a string, therefore + is seen as concatenation, and null becomes a string whose contents are 'null' when converted          to a string.
    - E: true + 3 = 4 because true is equivalent to 1 when numeric conversion occurs, and numeric conversion occurs because + is a math operation when not dealing            with strings. 
    - F: false + null = 0 because + is going to cause them to be converted into numbers, and both false and null become 0 after undergoing numeric conversion. 
    - G: '3' + undefined = 3undefined because '3' is seen as a string, so + is concatenate, and undefined just becomes 
    'undefined during string conversion. 
    - H: '3' - undefined = NaN because undefined becomes NaN as a number, and they go through numeric conversion because - is a math operation. 
14. - A: '2' > 1 will return true because when comparing values of different types, JavaScript converts both values to numbers, meaning '2' will be converted to the       number 2 and it is true that 2 is greater than 1
    - B: '2' < '12' returns false because JavaScript will compare the character codes for 2 and 1 (first char in 12) and see that 2 is greater than 1, meaning '2'         is greater than '12' 
    - C: 2 == '2' returns true because the string becomes the number 2, and 2 is equal to 2. 
    - D: 2 === '2' returns false because === checks without type conversion, meaning if the two things being compared are of different types, it automatically             returns false. 
    - E: true == 2 returns false because true is equivalent to 1 when it is converted into a number
    - F: true === Boolean(2) returns true because boolean() will return true for any non-zero number, and since 2 is non-zero, it will return true. Since true ===         true, the expression returns true 
15. The difference between == and === is that == compares after converting the two things being compared to the same type whereas === checks without converting the     type, meaning that if the types are different, === will always return false (== is an equality check whereas === is a strict equality check). 
17. (17) The result of the modifyArray function when passing in the array and using doSomething as the callback function is the array [2,4,6] which is two times              every element in the input array. This is the result because the modify array function takes in an array and calls the callback function on every element            of that array to create a new array. Since doSomething multiplies every element by two, the new array is the old one with every element doubled. 
19. (19) The output of the code is 1 4 3 2 (separate lines) because the timeouts run after the others because they are delayed.  
